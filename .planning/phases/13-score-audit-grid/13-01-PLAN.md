---
phase: 13-score-audit-grid
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/shared/score-audit-dialog.tsx
  - src/app/play/page.tsx
  - src/app/results/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can open the score audit grid from the play page header icon button"
    - "User can open the score audit grid from the results page header icon button"
    - "Audit grid shows raw stroke values for every hole and every player in a table (rows=holes, cols=players)"
    - "Unscored holes show an em dash, not an empty cell"
    - "Audit grid shows a collapsible handicap legend below the stroke table listing each pair and its handicap holes"
    - "Tapping a hole row on the play page closes the dialog and navigates to that hole via goToHole(n)"
    - "Tapping a hole row on the results page closes the dialog and opens the existing editingCell overlay for the first player of that hole"
  artifacts:
    - path: "src/components/shared/score-audit-dialog.tsx"
      provides: "ScoreAuditDialog component — full-height Dialog with stroke grid and handicap legend"
      exports: ["ScoreAuditDialog"]
      min_lines: 80
    - path: "src/app/play/page.tsx"
      provides: "Audit trigger button in play page header"
      contains: "ScoreAuditDialog"
    - path: "src/app/results/page.tsx"
      provides: "Audit trigger button in results page header"
      contains: "ScoreAuditDialog"
  key_links:
    - from: "src/app/play/page.tsx"
      to: "src/components/shared/score-audit-dialog.tsx"
      via: "import ScoreAuditDialog, passed onHoleSelect calling goToHole + close"
      pattern: "ScoreAuditDialog"
    - from: "src/app/results/page.tsx"
      to: "src/components/shared/score-audit-dialog.tsx"
      via: "import ScoreAuditDialog, passed onHoleSelect calling setEditingCell for first player of hole"
      pattern: "ScoreAuditDialog"
    - from: "src/components/shared/score-audit-dialog.tsx"
      to: "src/lib/game-store.ts"
      via: "useGameStore() — reads holeStrokes, config.handicaps, config.players"
      pattern: "useGameStore"
---

<objective>
Build the ScoreAuditDialog shared component and wire it into both the play and results pages as a header icon button.

Purpose: Satisfies all four AUDIT requirements — users can open a raw stroke grid during play (AUDIT-01) or on results (AUDIT-02), see handicap holes per pair (AUDIT-03), and tap any hole to navigate/edit (AUDIT-04).

Output:
- `src/components/shared/score-audit-dialog.tsx` — new shared dialog
- `src/app/play/page.tsx` — audit trigger in header + play-page onHoleSelect handler
- `src/app/results/page.tsx` — audit trigger in header + results-page onHoleSelect handler
</objective>

<execution_context>
@/Users/ohmmingrath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohmmingrath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-score-audit-grid/13-RESEARCH.md

@src/lib/types.ts
@src/lib/game-store.ts
@src/lib/pairs.ts
@src/components/ui/dialog.tsx
@src/components/shared/handicap-edit-dialog.tsx
@src/app/play/page.tsx
@src/app/results/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScoreAuditDialog component</name>
  <files>src/components/shared/score-audit-dialog.tsx</files>
  <action>
Create `src/components/shared/score-audit-dialog.tsx` as a "use client" component.

**Props interface:**
```ts
interface ScoreAuditDialogProps {
  trigger: React.ReactNode;
  onHoleSelect: (holeNumber: number) => void;
  mode: "play" | "results";
}
```

**Component structure:**

1. Read from store: `const { config, holeStrokes } = useGameStore();`
2. Return `null` if `!config?.players?.length`.
3. Import and use `Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogTrigger` from `@/components/ui/dialog`.
4. Use a local `useState(false)` for `open`. Expose `setOpen` so the onHoleSelect handler can close the dialog.
5. **DialogContent className override** (bottom-sheet style, full-height):
   ```
   "max-w-full h-[90dvh] top-[10dvh] translate-y-0 flex flex-col p-0 gap-0 rounded-t-2xl rounded-b-none left-0 translate-x-0"
   ```
   Set `showCloseButton={false}` to suppress the default X.
6. **DialogHeader** (sticky inside the sheet):
   - `DialogTitle`: "Score Audit"
   - `DialogDescription` (visually hidden with `className="sr-only"`): "Raw stroke entries per hole per player. Tap a hole to navigate or edit."
   - A close button on the right: `<button onClick={() => setOpen(false)}>` with an `X` icon from lucide-react (class `h-9 w-9 rounded-lg flex items-center justify-center text-muted-foreground hover:text-foreground hover:bg-muted/50 transition-colors`).
7. **Scrollable body** (`flex-1 overflow-y-auto p-4 space-y-4`):

   **Part A — Stroke grid:**
   ```tsx
   <div className="overflow-x-auto scrollbar-hide">
     <table className="w-full text-sm">
       <thead>
         <tr className="border-b border-border">
           <th className="text-left py-2 pr-3 text-muted-foreground font-medium w-10">Hole</th>
           {config.players.map(p => (
             <th key={p.id} className="text-center px-1.5 py-2 text-muted-foreground font-medium max-w-[48px] truncate">
               {/* Truncate to first 3 chars to handle 6-player mobile layout */}
               {p.name.slice(0, 3)}
             </th>
           ))}
         </tr>
       </thead>
       <tbody>
         {Array.from({ length: config.numberOfHoles }, (_, i) => i + 1).map(hole => {
           const holeData = holeStrokes.find(s => s.holeNumber === hole);
           const scored = !!holeData;
           return (
             <tr
               key={hole}
               className={`border-b border-border/50 last:border-0 transition-colors ${scored ? "cursor-pointer active:bg-muted/50" : "opacity-50"}`}
               onClick={() => {
                 if (!scored) return;
                 onHoleSelect(hole);
                 setOpen(false);
               }}
             >
               <td className="py-2.5 pr-3 font-bold tabular-nums text-foreground">{hole}</td>
               {config.players.map(p => {
                 const val = holeData?.strokes[p.id];
                 return (
                   <td key={p.id} className="text-center px-1.5 py-2.5 tabular-nums text-foreground">
                     {val != null ? val : <span className="text-muted-foreground/30">&#8212;</span>}
                   </td>
                 );
               })}
             </tr>
           );
         })}
       </tbody>
     </table>
   </div>
   ```

   **Part B — Handicap legend (collapsible):**

   Use a local `useState(false)` for `legendOpen`.

   Import `generatePairs, getPlayerName` from `@/lib/pairs`.

   Only render the legend section if at least one pair has `handicapHoles.length > 0`:
   ```tsx
   const pairs = generatePairs(config.players);
   const pairsWithHandicap = pairs.filter(pair => {
     const h = config.handicaps[pair.pairKey];
     return h && h.handicapHoles.length > 0;
   });
   ```

   If `pairsWithHandicap.length === 0`, render nothing for this section.

   Otherwise render a collapsible section:
   ```tsx
   <div className="glass-card overflow-hidden">
     <button
       className="w-full flex items-center justify-between px-4 py-3 text-sm font-medium text-foreground"
       onClick={() => setLegendOpen(v => !v)}
     >
       <span>Handicap Holes by Pair</span>
       <ChevronDown className={`h-4 w-4 text-muted-foreground transition-transform ${legendOpen ? "rotate-180" : ""}`} />
     </button>
     {legendOpen && (
       <div className="px-4 pb-4 space-y-2 border-t border-border">
         {pairsWithHandicap.map(pair => {
           const h = config.handicaps[pair.pairKey];
           const aName = getPlayerName(config.players, pair.playerAId);
           const bName = getPlayerName(config.players, pair.playerBId);
           return (
             <div key={pair.pairKey} className="text-sm">
               <span className="font-medium text-foreground">{aName} vs {bName}</span>
               <span className="text-muted-foreground ml-2">
                 Holes: {h.handicapHoles.sort((a, b) => a - b).join(", ")}
               </span>
               <span className="text-muted-foreground/60 text-xs ml-2">
                 ({h.value > 0 ? aName : bName} gives {Math.abs(h.value)})
               </span>
             </div>
           );
         })}
       </div>
     )}
   </div>
   ```

**Full imports needed:**
- `useState` from `"react"`
- `X, ChevronDown` from `"lucide-react"`
- `Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogTrigger` from `"@/components/ui/dialog"`
- `useGameStore` from `"@/lib/game-store"`
- `generatePairs, getPlayerName` from `"@/lib/pairs"`

**Pitfall notes:**
- Always include `DialogDescription` (even sr-only) to satisfy Radix accessibility requirement and avoid console warnings.
- Unscored rows: set `opacity-50` and do NOT call `onHoleSelect` on click (guard with `if (!scored) return`).
- Do NOT close dialog inside `onHoleSelect` — close it in the click handler here, after calling `onHoleSelect`. The caller's handler does not need to close anything.
- Use `setOpen` directly in click handler: call `onHoleSelect(hole)` then `setOpen(false)`.
  </action>
  <verify>
    Run `npm run lint` — zero TypeScript or ESLint errors in the new file.
    Confirm `src/components/shared/score-audit-dialog.tsx` exists and exports `ScoreAuditDialog`.
  </verify>
  <done>
    ScoreAuditDialog component exists, compiles cleanly, renders a full-height bottom-sheet Dialog with a stroke table (rows=holes, cols=players), em-dash for unscored cells, and a collapsible handicap legend section. No TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ScoreAuditDialog into play page and results page headers</name>
  <files>src/app/play/page.tsx, src/app/results/page.tsx</files>
  <action>
**In `src/app/play/page.tsx`:**

1. Add import at top: `import { ScoreAuditDialog } from "@/components/shared/score-audit-dialog";`
2. Destructure `goToHole` from `useGameStore()` (already destructured — confirm it is present).
3. In the header JSX (line ~185-193), add `<ScoreAuditDialog>` as a second icon button to the LEFT of `<HandicapEditDialog />`:

```tsx
<header className="sticky top-0 z-50 bg-card/90 backdrop-blur-xl border-b border-border px-4 py-3 flex items-center gap-3">
  <h1 className="text-lg font-bold flex-1 truncate text-foreground">
    Hole {currentHole}
    <span className="text-muted-foreground font-normal text-sm ml-1">
      / {config.numberOfHoles}
    </span>
  </h1>
  <ScoreAuditDialog
    trigger={
      <button
        className="h-9 w-9 rounded-lg flex items-center justify-center text-muted-foreground hover:text-foreground hover:bg-muted/50 transition-colors"
        aria-label="Score audit"
      >
        <TableProperties className="h-5 w-5" />
      </button>
    }
    onHoleSelect={(hole) => {
      goToHole(hole);
      // Dialog closes itself after calling onHoleSelect
    }}
    mode="play"
  />
  <HandicapEditDialog />
</header>
```

4. Add `TableProperties` to the lucide-react import at the top of play/page.tsx (it already imports from lucide-react — add `TableProperties` to the destructure list).

---

**In `src/app/results/page.tsx`:**

1. Add import at top: `import { ScoreAuditDialog } from "@/components/shared/score-audit-dialog";`
2. The page already has `editingCell` state and `handleEditStroke(playerId, playerName, hole)`. For the audit dialog's `onHoleSelect`, we need to open editingCell for the FIRST player of the selected hole:

```tsx
const handleAuditHoleSelect = (hole: number) => {
  // Open edit overlay for first player of this hole
  const firstPlayer = config?.players[0];
  if (!firstPlayer) return;
  setEditingCell({ playerId: firstPlayer.id, playerName: firstPlayer.name, hole });
};
```

Define this handler inside the component body (after `setEditingCell` is available).

3. In the header JSX (line ~97-100), add `<ScoreAuditDialog>` to the LEFT of `<HandicapEditDialog />`:

```tsx
<header className="sticky top-0 z-50 bg-card/90 backdrop-blur-xl border-b border-border px-4 py-4 flex items-center">
  <h1 className="text-lg font-bold text-foreground flex-1">Final Results</h1>
  <ScoreAuditDialog
    trigger={
      <button
        className="h-9 w-9 rounded-lg flex items-center justify-center text-muted-foreground hover:text-foreground hover:bg-muted/50 transition-colors"
        aria-label="Score audit"
      >
        <TableProperties className="h-5 w-5" />
      </button>
    }
    onHoleSelect={handleAuditHoleSelect}
    mode="results"
  />
  <HandicapEditDialog />
</header>
```

4. Add `TableProperties` to the lucide-react import in results/page.tsx.

**Important:** The `handleAuditHoleSelect` function uses `config` which could be null at the point the handler is defined. Guard with `if (!firstPlayer) return`. The `config` null check is already handled at line ~47 (`if (!config?.players?.length) return null;`), so by the time JSX renders, config is non-null — but still guard in the handler for TypeScript satisfaction.
  </action>
  <verify>
    Run `npm run build` — zero TypeScript errors, build succeeds.
    Run `npm run lint` — zero ESLint errors in modified files.
    Manual verification: open dev server (`npm run dev`), navigate to `/play`, open the audit dialog via the new header icon, verify the stroke grid appears and tapping a scored hole navigates to it. Navigate to `/results`, open audit dialog, tap a hole row, verify the edit overlay opens for that hole's first player.
  </verify>
  <done>
    Both play page and results page have a TableProperties icon button in the header that opens the ScoreAuditDialog. On play: tapping a scored hole closes dialog and navigates to that hole. On results: tapping a scored hole closes dialog and opens the existing edit overlay for the first player of that hole. Build and lint pass with zero errors.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` — zero errors across all three modified/created files
2. `npm run build` — production build succeeds with no TypeScript errors
3. `npm test` — existing test suite passes unchanged (no regressions)
4. Manual: `/play` page shows two icon buttons in header (TableProperties + Settings2). Tapping TableProperties opens a bottom-sheet dialog with a stroke grid and handicap legend. Tapping any scored hole row closes the dialog and shows that hole's stroke inputs.
5. Manual: `/results` page shows two icon buttons in header. Tapping TableProperties opens same dialog. Tapping a scored hole row closes dialog and opens the edit overlay pre-populated for that hole's first player.
6. Manual: Audit dialog on a game with no handicaps shows no handicap legend section (or the section does not render). With handicaps configured, the collapsible legend lists each pair and its handicap hole numbers.
7. Manual: With 6 players, all player name headers are visible (truncated to 3 chars) without needing horizontal scroll on the Hole column.
</verification>

<success_criteria>
- All four AUDIT requirements satisfied:
  - AUDIT-01: ScoreAuditDialog openable from play page header
  - AUDIT-02: Same dialog openable from results page header
  - AUDIT-03: Handicap holes per pair shown in collapsible legend below the stroke grid
  - AUDIT-04: Tapping a scored hole row navigates/edits (play: goToHole, results: editingCell)
- Zero new dependencies added
- Zero TypeScript or ESLint errors
- Existing test suite passes (no regressions)
- Dialog is accessible: includes DialogDescription for aria-describedby
</success_criteria>

<output>
After completion, create `.planning/phases/13-score-audit-grid/13-01-SUMMARY.md` following the summary template.
</output>
