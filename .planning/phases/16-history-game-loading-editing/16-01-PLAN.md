---
phase: 16-history-game-loading-editing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/game-store.ts
  - src/lib/types.ts
  - src/hooks/use-save-game.ts
autonomous: true

must_haves:
  truths:
    - "Loading a HistoryRecord into the Zustand store hydrates all game state fields correctly"
    - "Edits to a history-loaded game persist back to the SAME IndexedDB record (not a new one)"
    - "The historyId field is null for normal live games and set to the record ID for history-loaded games"
  artifacts:
    - path: "src/lib/game-store.ts"
      provides: "loadHistoryGame action + historyId field on GameStore"
      contains: "loadHistoryGame"
    - path: "src/lib/types.ts"
      provides: "historyId field on GameState"
      contains: "historyId"
    - path: "src/hooks/use-save-game.ts"
      provides: "History-aware save that updates existing record when historyId is set"
      contains: "historyId"
  key_links:
    - from: "src/lib/game-store.ts"
      to: "src/lib/types.ts"
      via: "GameState.historyId field"
      pattern: "historyId.*number.*null"
    - from: "src/hooks/use-save-game.ts"
      to: "src/lib/game-store.ts"
      via: "reads historyId from store"
      pattern: "historyId"
---

<objective>
Add history game loading infrastructure to the Zustand store and update the save hook to support editing history games.

Purpose: Enable the two-store bridge -- loading a past game FROM IndexedDB INTO the Zustand game store, and saving edits BACK to the same IndexedDB record.

Output: Modified game-store.ts with `loadHistoryGame` action, modified types.ts with `historyId` field, modified use-save-game.ts with history-aware save logic.
</objective>

<execution_context>
@/Users/ohmmingrath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohmmingrath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/game-store.ts
@src/lib/types.ts
@src/hooks/use-save-game.ts
@src/lib/history-db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add historyId field and loadHistoryGame action to Zustand store</name>
  <files>src/lib/types.ts, src/lib/game-store.ts</files>
  <action>
1. In `src/lib/types.ts`, add `historyId: number | null;` to the `GameState` interface. This tracks which IndexedDB record is currently loaded (null for live games).

2. In `src/lib/game-store.ts`:
   - Add `historyId: null` to `initialState`.
   - Add `loadHistoryGame` action to the `GameStore` interface:
     ```
     loadHistoryGame: (record: HistoryRecord) => void;
     ```
     Import `HistoryRecord` from `@/lib/history-db`.
   - Implement `loadHistoryGame`: it should call `set()` with ALL fields from the HistoryRecord hydrated into GameState:
     ```
     loadHistoryGame: (record) =>
       set({
         config: record.config,
         currentHole: record.numberOfHoles,
         holeStrokes: record.holeStrokes,
         pairResults: record.pairResults,
         playerScores: record.playerScores,
         isComplete: true,
         historyId: record.id ?? null,
         _undoSnapshot: null,
       }),
     ```
   - Update `resetGame` to also reset `historyId: null`.
   - Update `partialize` to exclude `historyId` from localStorage persistence (history games should not persist as the "current game" -- they are viewed transiently). Actually on reflection, DO include historyId in persistence so that if the user refreshes while viewing a history game, the save hook can still find the right record. But reset it in `resetGame`.

3. IMPORTANT: Do NOT change the persist `version` number -- this is an additive non-breaking change (historyId defaults to undefined/null for existing persisted state).
  </action>
  <verify>
Run `npm run build` -- should compile with no TypeScript errors. Run `npm test` -- all 118+ tests should pass (no behavior change to existing functionality).
  </verify>
  <done>
GameState has `historyId: number | null` field. GameStore has `loadHistoryGame(record)` action that hydrates full game state from a HistoryRecord. `resetGame()` clears historyId. Build and tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update useSaveGame to support history game editing</name>
  <files>src/hooks/use-save-game.ts</files>
  <action>
Rewrite `useSaveGame` hook to handle two modes:

**Normal mode (historyId is null):** Current behavior -- first save creates a new IndexedDB record (stores ID in savedIdRef), subsequent changes update that record. No change needed here.

**History mode (historyId is a number):** Edits should update the existing IndexedDB record identified by historyId. The hook should:
1. Read `historyId` from the game store: `const { historyId } = useGameStore()`.
2. When `historyId` is set AND isComplete is true, always use `historyDb.games.update(historyId, { ...record })` (never `add`).
3. Preserve the original `completedAt` timestamp -- do NOT overwrite it. Pass `completedAt: undefined` in the update payload (Dexie ignores undefined fields).
4. Do NOT set `savedIdRef` when in history mode -- it's not needed since historyId is already the record ID.

The effect dependency array must include `historyId` alongside the existing deps.

Key detail: When `historyId` changes from null to a number (history game loaded), the effect should NOT immediately fire a save. It should only save when OTHER deps change (config, holeStrokes, etc.) indicating an actual edit. Use a ref to track the previous historyId and skip the first fire after a historyId change.

Actually, simpler approach: the current useSaveGame fires on ANY change to its deps. When we load a history game, loadHistoryGame sets isComplete=true and all the data at once, which triggers the effect. But since we're loading existing data (not editing), we should not save on first load. Solution: use a `skipNextSave` ref that gets set to true when historyId transitions from null to a number. When the effect fires and skipNextSave is true, flip it to false and return early.

Implementation:
```typescript
export function useSaveGame() {
  const savedIdRef = useRef<number | null>(null);
  const skipNextSaveRef = useRef(false);
  const prevHistoryIdRef = useRef<number | null>(null);
  const { isComplete, config, holeStrokes, pairResults, playerScores, historyId } =
    useGameStore();

  useEffect(() => {
    // Detect history game load (historyId changed from null to a number)
    if (historyId !== prevHistoryIdRef.current) {
      prevHistoryIdRef.current = historyId;
      if (historyId !== null) {
        // History game just loaded -- skip this save trigger
        skipNextSaveRef.current = true;
        return;
      }
    }

    if (skipNextSaveRef.current) {
      skipNextSaveRef.current = false;
      return;
    }

    if (!isComplete || !config) return;

    const rankings = getFinalRankings(config.players, playerScores);
    const record: Omit<HistoryRecord, "id"> = {
      completedAt: new Date().toISOString(),
      players: config.players.map((p) => ({ id: p.id, name: p.name })),
      numberOfHoles: config.numberOfHoles,
      rankings: rankings.map((r) => ({
        playerId: r.player.id,
        playerName: r.player.name,
        totalScore: r.totalScore,
        rank: r.rank,
      })),
      winnerId: rankings[0]?.player.id ?? "",
      winnerName: rankings[0]?.player.name ?? "",
      config,
      holeStrokes,
      pairResults,
      playerScores,
    };

    if (historyId !== null) {
      // History mode: update existing record, preserve completedAt
      historyDb.games
        .update(historyId, {
          ...record,
          completedAt: undefined, // preserve original timestamp
        })
        .catch(console.error);
    } else if (savedIdRef.current) {
      // Normal mode: update existing record from this session
      historyDb.games
        .update(savedIdRef.current, {
          ...record,
          completedAt: undefined,
        })
        .catch(console.error);
    } else {
      // Normal mode: first save
      record.completedAt = new Date().toISOString();
      historyDb.games
        .add(record as HistoryRecord)
        .then((id) => {
          savedIdRef.current = id as number;
        })
        .catch(console.error);
    }
  }, [isComplete, config, holeStrokes, pairResults, playerScores, historyId]);
}
```

Note: The `skipNextSaveRef` pattern ensures that loading a history game does not trigger a redundant save. The first change to deps after the skip will be a real edit and WILL trigger a save.
  </action>
  <verify>
Run `npm run build` -- no TypeScript errors. Run `npm test` -- all tests pass. The hook logic can be tested manually in Plan 02's checkpoint.
  </verify>
  <done>
useSaveGame detects historyId from the store. When historyId is set, edits update the existing IndexedDB record (preserving completedAt). When historyId is null, original behavior is preserved. Loading a history game does not trigger a redundant save.
  </done>
</task>

</tasks>

<verification>
- `npm run build` compiles successfully
- `npm test` passes all existing tests (no regressions)
- `GameState` type includes `historyId: number | null`
- `loadHistoryGame` action exists on the store
- `useSaveGame` reads `historyId` and branches accordingly
</verification>

<success_criteria>
The Zustand store can accept a full HistoryRecord via `loadHistoryGame()`, hydrating all game state fields. The save hook correctly routes edits to update the original IndexedDB record when `historyId` is set. No regressions in existing game flow.
</success_criteria>

<output>
After completion, create `.planning/phases/16-history-game-loading-editing/16-01-SUMMARY.md`
</output>
