---
phase: 14-play-again-config-restore
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/hooks/use-play-again.ts
  - src/hooks/__tests__/use-play-again.test.ts
autonomous: true

must_haves:
  truths:
    - "remapHandicaps returns empty object when given empty handicaps"
    - "remapHandicaps correctly translates old PairKeys to new PairKeys via player name matching"
    - "remapHandicaps sets playerAId and playerBId from the recomputed sorted key (not raw newA/newB)"
    - "remapHandicaps preserves handicapHoles values on each remapped pair"
    - "remapHandicaps silently skips pairs where a player name has no match in new players"
    - "usePlayAgain hook exists and exports a callable function"
  artifacts:
    - path: "src/hooks/use-play-again.ts"
      provides: "Shared Play Again hook + remapHandicaps pure function"
      exports: ["usePlayAgain", "remapHandicaps"]
    - path: "src/hooks/__tests__/use-play-again.test.ts"
      provides: "Unit tests for remapHandicaps"
      contains: "describe.*remapHandicaps"
  key_links:
    - from: "src/hooks/use-play-again.ts"
      to: "src/lib/pairs.ts"
      via: "import makePairKey"
      pattern: "makePairKey"
    - from: "src/hooks/use-play-again.ts"
      to: "src/lib/game-store.ts"
      via: "useGameStore actions"
      pattern: "useGameStore"
---

<objective>
Extract the PairKey remapping logic as a tested pure function and build the shared `usePlayAgain` hook that both the home page and results page will call.

Purpose: The remap logic is the most failure-prone piece of this phase (old UUIDs become orphaned when new ones are generated). TDD catches UUID-mismatch bugs before integration. The shared hook eliminates duplicate code between the two call sites.

Output: `src/hooks/use-play-again.ts` with exported `remapHandicaps` (pure, testable) + `usePlayAgain` (React hook). `src/hooks/__tests__/use-play-again.test.ts` with passing tests.
</objective>

<execution_context>
@/Users/ohmmingrath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohmmingrath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/types.ts
@src/lib/pairs.ts
@src/lib/game-store.ts
@src/lib/__tests__/game-store.test.ts
</context>

<feature>
  <name>remapHandicaps pure function + usePlayAgain hook</name>
  <files>src/hooks/use-play-again.ts, src/hooks/__tests__/use-play-again.test.ts</files>
  <behavior>
    remapHandicaps(oldPlayers, newPlayers, handicaps) → Record&lt;PairKey, PairHandicap&gt;

    Test cases:
    - Empty handicaps → returns {}
    - Two players, one pair with value=2 and handicapHoles=[3,9]:
        oldPlayers=[{id:"old-a", name:"Alice"}, {id:"old-b", name:"Bob"}]
        newPlayers=[{id:"new-a", name:"Alice"}, {id:"new-b", name:"Bob"}]
        handicaps={"old-a::old-b": {pairKey:"old-a::old-b", playerAId:"old-a", playerBId:"old-b", value:2, handicapHoles:[3,9]}}
        → remapped key = makePairKey("new-a","new-b") e.g. "new-a::new-b"
        → result[newKey].value === 2
        → result[newKey].handicapHoles deepEqual [3,9]
        → result[newKey].pairKey === newKey
        → result[newKey].playerAId === newKey.split("::")[0]
        → result[newKey].playerBId === newKey.split("::")[1]
    - Player name not in newPlayers → that pair is skipped (no entry in result)
    - Three players: all three pairs remapped correctly

    usePlayAgain() returns a function handlePlayAgain(latestGame) that:
    - If latestGame is null/undefined, is a no-op
    - Calls resetGame(), setPlayers(newPlayers), setNumberOfHoles(latestGame.numberOfHoles)
    - Calls setHandicap(key, ph.value) then setHandicapHoles(key, ph.handicapHoles) for each remapped pair (ORDER CRITICAL: setHandicap first, then setHandicapHoles)
    - Calls setTurboHoles(latestGame.config.turboHoles)
    - Calls router.push("/setup")
  </behavior>
  <implementation>
    File: src/hooks/use-play-again.ts

    Export 1 — pure function (testable without React):
    ```typescript
    import { makePairKey } from "@/lib/pairs";
    import type { Player, PairKey, PairHandicap } from "@/lib/types";

    export function remapHandicaps(
      oldPlayers: Player[],
      newPlayers: Player[],
      handicaps: Record<PairKey, PairHandicap>
    ): Record<PairKey, PairHandicap> {
      // Build old-ID → new-ID map joined on player name
      const oldIdToNewId = new Map&lt;string, string&gt;();
      for (const oldP of oldPlayers) {
        const match = newPlayers.find((np) => np.name === oldP.name);
        if (match) oldIdToNewId.set(oldP.id, match.id);
      }

      const remapped: Record&lt;PairKey, PairHandicap&gt; = {};
      for (const ph of Object.values(handicaps)) {
        const newA = oldIdToNewId.get(ph.playerAId);
        const newB = oldIdToNewId.get(ph.playerBId);
        if (!newA || !newB) continue; // skip unresolvable pairs

        const newKey = makePairKey(newA, newB);
        // playerAId/playerBId must come from the sorted key, NOT from newA/newB directly
        // because makePairKey sorts alphabetically — the assignment may be swapped
        const [sortedA, sortedB] = newKey.split("::");
        remapped[newKey] = {
          ...ph,
          pairKey: newKey,
          playerAId: sortedA,
          playerBId: sortedB,
        };
      }
      return remapped;
    }
    ```

    Export 2 — React hook:
    ```typescript
    import { useRouter } from "next/navigation";
    import { useGameStore } from "@/lib/game-store";
    import type { HistoryRecord } from "@/lib/history-db"; // import type only

    export function usePlayAgain() {
      const router = useRouter();
      const { resetGame, setPlayers, setNumberOfHoles, setHandicap, setHandicapHoles, setTurboHoles } =
        useGameStore();

      return function handlePlayAgain(latestGame: HistoryRecord | null | undefined) {
        if (!latestGame) return;

        // Generate fresh UUIDs — NEVER reuse old player IDs
        const newPlayers = latestGame.players.map((p) => ({
          id: crypto.randomUUID(),
          name: p.name,
        }));

        // Remap handicap PairKeys from old UUIDs to new UUIDs
        const remapped = remapHandicaps(
          latestGame.players,
          newPlayers,
          latestGame.config.handicaps
        );

        resetGame();
        setPlayers(newPlayers);
        setNumberOfHoles(latestGame.numberOfHoles);

        // ORDER CRITICAL: setHandicap first (creates entry + resets handicapHoles to [])
        // then setHandicapHoles (patches handicapHoles onto the existing entry)
        for (const ph of Object.values(remapped)) {
          setHandicap(ph.pairKey, ph.value);
          setHandicapHoles(ph.pairKey, ph.handicapHoles);
        }

        setTurboHoles(latestGame.config.turboHoles);
        router.push("/setup");
      };
    }
    ```

    Test file: src/hooks/__tests__/use-play-again.test.ts
    - Import remapHandicaps directly (pure function, no React needed)
    - Mock nothing — remapHandicaps has zero side effects
    - Use vitest describe/it/expect pattern matching game-store.test.ts
    - Cover all behavior cases listed above
  </implementation>
</feature>

<verification>
Run: `npm test -- --reporter=verbose src/hooks/__tests__/use-play-again.test.ts`

All tests must pass (green). TypeScript must compile with no errors:
`npx tsc --noEmit`
</verification>

<success_criteria>
- `src/hooks/use-play-again.ts` exists and exports both `remapHandicaps` and `usePlayAgain`
- `src/hooks/__tests__/use-play-again.test.ts` has at minimum 5 test cases covering the listed behavior
- `npm test` passes (all 112+ tests green — no regressions)
- `npx tsc --noEmit` exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/14-play-again-config-restore/14-01-SUMMARY.md`
</output>
